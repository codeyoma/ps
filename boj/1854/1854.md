---
tags: ["ps/boj/platinum/4", "ps/boj/platinum", "cs/algorithms/data-structures/ps","cs/algorithms/graph-theory/ps","cs/algorithms/shortest-path/ps","cs/algorithms/dijkstra's/ps","cs/algorithms/priority-queue/ps"]
---

# Problem
- [https://www.acmicpc.net/problem/1854](https://www.acmicpc.net/problem/1854)
- [code on boj](https://www.acmicpc.net/status?problem_id=1854&user_id=hiatus4322)
- [code on github](https://github.com/codeyoma/ps/tree/main/boj/1854)


<br/>

<!--
# Logic

### *분석*
- 문제 유형 (알고리즘...)
- 제약 조건 (인풋 크기, 예외 값, 시공간 복잡도...)

### *설계*
1. 알고리즘 선택
2. 자료구조 선택
3. 수도 코드 작성
4. 정합판단
  - `1 ~ 3`과정으로 도출된 로직이 문제를 해결하는가
    - 그렇다 -> **구현**
    - 잘 모르겠다 -> **구현**
    - 아니다 -> 1번부터 다시 점검

### *구현*
- 로직 검증

### *테스트*
- 예외 케이스 고려

<br/>

-->

# My Code

## python
```python title="boj/1854.py"
# https://www.acmicpc.net/problem/1854
import sys
input = sys.stdin.readline


```

## cpp
```cpp title="boj/1854.cpp"
// https://www.acmicpc.net/problem/1854
#include <iostream>
using namespace std;

void fast_io() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
}

//--------------------------------------------------------------------------------------------------

#include <iostream>
#include <queue>
#include <vector>

struct Node {
    int cost;
    int v;

    bool operator>(const Node& other) const {
        return cost > other.cost;
    }
};

int main() {
    fast_io();

    //   logic

    int n, m, k;
    cin >> n >> m >> k;

    vector<vector<pair<int, int>>> adj(n + 1);
    vector<vector<int>>            dist(n + 1);

    priority_queue<Node, vector<Node>, greater<Node>> pq;

    for (int i = 0; i < m; ++i) {
        int s, d, w;
        cin >> s >> d >> w;

        adj[s].push_back({ d, w });
    }

    dist[1].push_back(0);
    pq.push({ 0, 1 });

    while (!pq.empty()) {
        const auto [cost, u] = pq.top();
        auto& du             = dist[u];
        pq.pop();

        if (du.size() == k && du.front() < cost) {
            continue;
        }

        for (const auto& [next, w]: adj[u]) {
            int   next_cost = w + cost;
            auto& dv        = dist[next];

            if (dv.size() < k) {
                dv.push_back(next_cost);
                push_heap(dv.begin(), dv.end());
                pq.push({ next_cost, next });
            } else if (dv.front() > next_cost) {
                pop_heap(dv.begin(), dv.end());
                dv.back() = next_cost;
                push_heap(dv.begin(), dv.end());
                pq.push({ next_cost, next });
            }
        }
    }

    for (int i = 1; i <= n; ++i) {
        if (dist[i].size() < k) {
            cout << "-1\n";
        } else {
            cout << dist[i].front() << "\n";
        }
    }
}

```
